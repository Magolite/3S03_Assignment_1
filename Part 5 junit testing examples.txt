Section 5 Responses: 

a) [6 marks] Generate a reasonable amount of JUnit tests via Gen AI. Touch them up manually if there are compilation errors. Measure the coverage. (Choose a reasonably complex coverage metric; not the most simplistic one!)  

The test code generated by GenAI are included below, and had a total coverage of 59.3% for the Assignment 1 code. I chose to measure coverage using branch coverage, as it is more meaningful than line coverage, given that it verifies that every decision point (or branch) in the code is exercised or executed by the tests. If I relied online coverage alone, it would have been possible to reach high line coverage and yet still miss some key decision points, so this approach ensures all key decisions are covered by tests.  

package com.example.shop; 

import org.junit.jupiter.api.Test; 

import static org.junit.jupiter.api.Assertions.*; 

public class OrderSystemTestInitial { 

  

    //OrderItem 

    @Test 

    void orderItem_validConstruction_returnsTotalPrice() { 

        OrderItem item = new OrderItem("Book", 3, 10.0); 

        assertEquals(30.0, item.getTotalPrice()); 

    } 

    @Test 

    void orderItem_zeroQuantity_throwsException() { 

        assertThrows(IllegalArgumentException.class, 

            () -> new OrderItem("Book", 0, 10.0)); 

    } 

    @Test 

    void orderItem_getQuantity_returnsCorrectValue() { 

        OrderItem item = new OrderItem("Hat", 5, 20.0); 

        assertEquals(5, item.getQuantity()); 

    } 

  

    //Order 

    @Test 

    void order_initialStatus_isCreated() { 

        Order order = new Order(); 

        assertEquals(OrderStatus.CREATED, order.getStatus()); 

    } 

    @Test 

    void order_addItem_whenCreated_succeeds() { 

        Order order = new Order(); 

        order.addItem(new OrderItem("Pen", 1, 2.0)); 

        assertEquals(1, order.getItems().size()); 

    } 

  

    //PricingService 

    @Test 

    void pricing_calculateSubtotal_multipleItems() { 

        Order order = new Order(); 

        order.addItem(new OrderItem("A", 2, 5.0)); 

        order.addItem(new OrderItem("B", 1, 10.0)); 

        PricingService ps = new PricingService(); 

        assertEquals(20.0, ps.calculateSubtotal(order)); 

    } 

    @Test 

    void pricing_calculateTax_positiveSubtotal() { 

        PricingService ps = new PricingService(); 

        assertEquals(20.0, ps.calculateTax(100.0)); 

    } 

  

    //DiscountService 

    @Test 

    void discount_student10_applies10PercentOff() { 

        DiscountService ds = new DiscountService(); 

        assertEquals(90.0, ds.applyDiscount(100.0, "STUDENT10")); 

    } 

    @Test 

    void discount_blackFriday_applies30PercentOff() { 

        DiscountService ds = new DiscountService(); 

        assertEquals(70.0, ds.applyDiscount(100.0, "BLACKFRIDAY")); 

    } 

  

    //PaymentValidator 

    @Test 

    void payment_card_returnsTrue() { 

        PaymentValidator pv = new PaymentValidator(); 

        assertTrue(pv.isPaymentMethodValid("card")); 

    } 

    @Test 

    void payment_paypal_returnsTrue() { 

        PaymentValidator pv = new PaymentValidator(); 

        assertTrue(pv.isPaymentMethodValid("paypal")); 

    } 

  

    //OrderService 

    @Test 

    void orderService_validPaymentNoDiscount_returnsCorrectTotal() { 

        OrderService os = new OrderService(); 

        Order order = new Order(); 

        order.addItem(new OrderItem("Item", 1, 100.0)); 

        double result = os.processOrder(order, "", "card"); 

        assertEquals(120.0, result); 

        assertEquals(OrderStatus.PAID, order.getStatus()); 

    } 

    @Test 

    void orderService_withStudent10Discount_returnsCorrectTotal() { 

        OrderService os = new OrderService(); 

        Order order = new Order(); 

        order.addItem(new OrderItem("Textbook", 1, 100.0)); 

        double result = os.processOrder(order, "STUDENT10", "paypal"); 

        assertEquals(108.0, result); 

        assertEquals(OrderStatus.PAID, order.getStatus()); 

    } 

} 

b) [16 marks] Work with Gen AI until you reach 90% coverage. You can use Gen AI, your own engineering skills, or a mix of the two to reach the desired coverage. Hint: Be creative and think about what Gen AI is good for and what your engineering skills are good for.  

If you reached 90% coverage, how much time it has taken?  

What strategy did you use? (For example, did you switch between AI and human once, multiple times, regularly? Was there a role the AI played and role the human played?)  

Given the 59.3% coverage case above, I recognized that it was time to improve the tests to ensure that they reach 90% or higher branch coverage. This was done by first going to check the branches that may not be covered, and thinking up tests for them. I then passed these requests to generative Ai and asked it to recommend test structures that I could use to meet the requirement for that branch. I then took the generated code and modified it so that it would compile and run as intended. This order of human input, generative AI feedback, and human refinement allowed me to reach 100% branch coverage within two hours. In this case, the AI contributes pattern recognition in recognizing the necessary structure for the tests, while my own human input helped with recognizing any environment or project-specific aspects that were missing such as edge cases for certain branches, exceptions that weren’t handled properly, or issues with state logic and behaviour.. In this case, I used the AI to essentially create ‘templates’ that could be used to write the remainder of the tests to meet the required coverage standard.  
 
The complete set of tests is below: 
package com.example.shop; 

import org.junit.jupiter.api.Test; 

import static org.junit.jupiter.api.Assertions.*; 

 

public class OrderSystemTest { 

  

    //OrderItem 

    @Test 

    void orderItem_validConstruction_returnsTotalPrice() { 

        OrderItem item = new OrderItem("Book", 3, 10.0); 

        assertEquals(30.0, item.getTotalPrice()); 

    } 

    @Test 

    void orderItem_zeroQuantity_throwsException() { 

        assertThrows(IllegalArgumentException.class, 

            () -> new OrderItem("Book", 0, 10.0)); 

    } 

    @Test 

    void orderItem_negativeQuantity_throwsException() { 

        assertThrows(IllegalArgumentException.class, 

            () -> new OrderItem("Book", -1, 10.0)); 

    } 

    @Test 

    void orderItem_negativeUnitPrice_throwsException() { 

        assertThrows(IllegalArgumentException.class, 

            () -> new OrderItem("Book", 1, -5.0)); 

    } 

  

    @Test 

    void orderItem_zeroPriceIsAllowed() { 

        OrderItem item = new OrderItem("Freebie", 2, 0.0); 

        assertEquals(0.0, item.getTotalPrice()); 

    } 

    @Test 

    void orderItem_getQuantity_returnsCorrectValue() { 

        OrderItem item = new OrderItem("Hat", 5, 20.0); 

        assertEquals(5, item.getQuantity()); 

    } 

  

    //Order 

    @Test 

    void order_initialStatus_isCreated() { 

        Order order = new Order(); 

        assertEquals(OrderStatus.CREATED, order.getStatus()); 

    } 

    @Test 

    void order_addItem_whenCreated_succeeds() { 

        Order order = new Order(); 

        order.addItem(new OrderItem("Pen", 1, 2.0)); 

        assertEquals(1, order.getItems().size()); 

    } 

    @Test 

    void order_addItem_afterPaid_throwsException() { 

        Order order = new Order(); 

        order.setStatus(OrderStatus.PAID); 

        assertThrows(IllegalStateException.class, 

            () -> order.addItem(new OrderItem("Pen", 1, 2.0))); 

    } 

    @Test 

    void order_addItem_afterCancelled_throwsException() { 

        Order order = new Order(); 

        order.setStatus(OrderStatus.CANCELLED); 

        assertThrows(IllegalStateException.class, 

            () -> order.addItem(new OrderItem("Pen", 1, 2.0))); 

    } 

    @Test 

    void order_setStatus_updatesStatus() { 

        Order order = new Order(); 

        order.setStatus(OrderStatus.PAID); 

        assertEquals(OrderStatus.PAID, order.getStatus()); 

    } 

  

    //PricingService 

    @Test 

    void pricing_calculateSubtotal_multipleItems() { 

        Order order = new Order(); 

        order.addItem(new OrderItem("A", 2, 5.0)); 

        order.addItem(new OrderItem("B", 1, 10.0)); 

        PricingService ps = new PricingService(); 

        assertEquals(20.0, ps.calculateSubtotal(order)); 

    } 

    @Test 

    void pricing_calculateSubtotal_emptyOrder_returnsZero() { 

        Order order = new Order(); 

        PricingService ps = new PricingService(); 

        assertEquals(0.0, ps.calculateSubtotal(order)); 

    } 

    @Test 

    void pricing_calculateTax_positiveSubtotal() { 

        PricingService ps = new PricingService(); 

        assertEquals(20.0, ps.calculateTax(100.0)); 

    } 

    @Test 

    void pricing_calculateTax_zeroSubtotal_returnsZero() { 

        PricingService ps = new PricingService(); 

        assertEquals(0.0, ps.calculateTax(0.0)); 

    } 

    @Test 

    void pricing_calculateTax_negativeSubtotal_throwsException() { 

        PricingService ps = new PricingService(); 

        assertThrows(IllegalArgumentException.class, 

            () -> ps.calculateTax(-1.0)); 

    } 

  

    //DiscountService 

    @Test 

    void discount_nullCode_returnsOriginalSubtotal() { 

        DiscountService ds = new DiscountService(); 

        assertEquals(100.0, ds.applyDiscount(100.0, null)); 

    } 

    @Test 

    void discount_blankCode_returnsOriginalSubtotal() { 

        DiscountService ds = new DiscountService(); 

        assertEquals(100.0, ds.applyDiscount(100.0, "   ")); 

    } 

    @Test 

    void discount_student10_applies10PercentOff() { 

        DiscountService ds = new DiscountService(); 

        assertEquals(90.0, ds.applyDiscount(100.0, "STUDENT10")); 

    } 

    @Test 

    void discount_student10_caseInsensitive() { 

        DiscountService ds = new DiscountService(); 

        assertEquals(90.0, ds.applyDiscount(100.0, "student10")); 

    } 

    @Test 

    void discount_blackFriday_applies30PercentOff() { 

        DiscountService ds = new DiscountService(); 

        assertEquals(70.0, ds.applyDiscount(100.0, "BLACKFRIDAY")); 

    } 

    @Test 

    void discount_invalidCode_throwsException() { 

        DiscountService ds = new DiscountService(); 

        assertThrows(IllegalArgumentException.class, 

            () -> ds.applyDiscount(100.0, "INVALID")); 

    } 

    @Test 

    void discount_unknownCode_returnsOriginalSubtotal() { 

        DiscountService ds = new DiscountService(); 

        assertEquals(100.0, ds.applyDiscount(100.0, "RANDOMCODE")); 

    } 

  

    //PaymentValidator 

    @Test 

    void payment_nullMethod_returnsFalse() { 

        PaymentValidator pv = new PaymentValidator(); 

        assertFalse(pv.isPaymentMethodValid(null)); 

    } 

    @Test 

    void payment_card_returnsTrue() { 

        PaymentValidator pv = new PaymentValidator(); 

        assertTrue(pv.isPaymentMethodValid("card")); 

    } 

    @Test 

    void payment_cardUpperCase_returnsTrue() { 

        PaymentValidator pv = new PaymentValidator(); 

        assertTrue(pv.isPaymentMethodValid("CARD")); 

    } 

    @Test 

    void payment_paypal_returnsTrue() { 

        PaymentValidator pv = new PaymentValidator(); 

        assertTrue(pv.isPaymentMethodValid("paypal")); 

    } 

    @Test 

    void payment_crypto_returnsFalse() { 

        PaymentValidator pv = new PaymentValidator(); 

        assertFalse(pv.isPaymentMethodValid("crypto")); 

    } 

    @Test 

    void payment_unknownMethod_throwsException() { 

        PaymentValidator pv = new PaymentValidator(); 

        assertThrows(UnsupportedOperationException.class, 

            () -> pv.isPaymentMethodValid("bitcoin")); 

    } 

  

    //OrderService 

    @Test 

    void orderService_invalidPayment_cancelOrderAndReturnsZero() { 

        OrderService os = new OrderService(); 

        Order order = new Order(); 

        order.addItem(new OrderItem("Widget", 1, 50.0)); 

        double result = os.processOrder(order, null, "crypto"); 

        assertEquals(0.0, result); 

        assertEquals(OrderStatus.CANCELLED, order.getStatus()); 

    } 

    @Test 

    void orderService_nullPayment_cancelOrderAndReturnsZero() { 

        OrderService os = new OrderService(); 

        Order order = new Order(); 

        order.addItem(new OrderItem("Widget", 1, 50.0)); 

        double result = os.processOrder(order, null, null); 

        assertEquals(0.0, result); 

        assertEquals(OrderStatus.CANCELLED, order.getStatus()); 

    } 

    @Test 

    void orderService_validPaymentNoDiscount_returnsCorrectTotal() { 

        OrderService os = new OrderService(); 

        Order order = new Order(); 

        order.addItem(new OrderItem("Item", 1, 100.0)); 

        // subtotal=100, no discount, tax=20 → total=120 

        double result = os.processOrder(order, "", "card"); 

        assertEquals(120.0, result); 

        assertEquals(OrderStatus.PAID, order.getStatus()); 

    } 

    @Test 

    void orderService_withStudent10Discount_returnsCorrectTotal() { 

        OrderService os = new OrderService(); 

        Order order = new Order(); 

        order.addItem(new OrderItem("Textbook", 1, 100.0)); 

        // subtotal=100, 10% off=90, tax=18 → total=108 

        double result = os.processOrder(order, "STUDENT10", "paypal"); 

        assertEquals(108.0, result); 

        assertEquals(OrderStatus.PAID, order.getStatus()); 

    @Test 

    void orderService_withBlackFridayDiscount_returnsCorrectTotal() { 

        OrderService os = new OrderService(); 

        Order order = new Order(); 

        order.addItem(new OrderItem("TV", 1, 100.0)); 

        // subtotal=100, 30% off=70, tax=14 → total=84 

        double result = os.processOrder(order, "BLACKFRIDAY", "card"); 

        assertEquals(84.0, result); 

    } 

    @Test 

    void orderService_emptyOrderValidPayment_returnsZero() { 

        OrderService os = new OrderService(); 

        Order order = new Order(); 

        double result = os.processOrder(order, null, "card"); 

        assertEquals(0.0, result); 

        assertEquals(OrderStatus.PAID, order.getStatus()); 

    } 

} 

c) [4 marks] What are your key takeaways from this exercise? What is gen AI useful for and what is human cognition useful for in this particular setting (testing and reaching test coverage)?  

Based on this exercise, my key takeaways are that the AI is very good at pattern matching and generating template or boilerplate code and tests, but often struggles with the nuances of developing specific test cases to meet required coverage standards or metrics. Generative AI is very helpful for developing a base set of tests to base a test suite on, as it is able to cover a little over half of the branches and catches obvious edge cases such as null inputs, empty lists, or validation rules such as negative value inputs. Because all of these kinds of tests follow very specific patterns and structure, the AI does a good job of creating them. However, it struggles with the more complex elements such as finding deeper logical contexts, business logic and semantics of the program, and deciding what coverage is considered meaningful. It is these points in test development that require human input. Continually prompting a generative AI model may help get relatively high coverage, but in order to achieve the last ~20% of coverage, human input is needed as humans are able to recognize and understand the additional context that is needed to achieve high branch coverage percentages.  

d) [4 marks] Based on your takeaways, envision the next generation of AI-enabled, human-in-the-loop testing tools, e.g., ones that you would like to work with. If you had to invest $1M into developing such tools, what would be the top features of that tool? What would be the biggest challenges of widespread adoption? 

If I were to invest in developing an AI testing tool, I would develop a custom human-in-the-loop testing tool with features such as live coverage monitoring, natural language input options, test redundancy detection, and an interactive coverage component. Live coverage monitoring and the live coverage dashboard would allow users to view live assessments of their test coverage ad what sections of code, lines, or branches are covered. This would make it easier for individuals to recognize what parts of their code may need more tests and what is already covered. The redundancy checker also helps to avoid unnecessary tests that may slow down program runtime or fill the codebase with unused tests. Finally, there would be the option for natural language input, which allows people to describe the intended context and goals of a specific test, which the agent will then interpret and draft a test for. This allows the agent to gain additional context as to what may be needed for the tests by gathering information from human developers, who have a much higher capacity to understand the full project scope and context.  

Though this tool would be very helpful , there are a few potential challenges to widespread adoption of the tool. The first issue is that of trust and correctness. Some safety-critical or restricted access projects may not allow for the use of external (non company-made) tools for code generation or analysis due to security or safety risks. There is also the issue of the tool potentially struggling with large legacy codebases, where people may not be able to provide all of the context needed in a simple message, in order to enable the tool to help produce tests as expected. Legacy code is often complex and the tool may struggle to work effectively on it. The final risk is that of over reliance on the software testing tool and coverage metrics. If teams use the tool with the sole intention of reaching coverage numbers without ensuring that their coverage is correct and genuinely improves code quality, the tool may prove harmful or non-beneficial.  
