Question 3 Responses: 

a) [1.5 marks] Given the following interface, how would you decouple the agents’ 

behaviour from your current focus, i.e., core game dynamics? Explain the idea and 

justify it. 

public interface CatanAgent { 

void init(int playerId); 

Move chooseInitialSettlement(GameState state); 

Move chooseInitialRoad(GameState state); 

Move chooseMove(GameState state); 

Map<ResourceType, Integer> chooseDiscard(GameState state,int discardCount); 

ResourceType chooseResource(GameState state); 

int chooseRobberTarget(GameState state, List<Integer> possibleTargets); 

DevelopmentCard chooseDevelopmentCard(GameState state); 

} 

In order to decouple the agent’s behaviour from the core game module or dynamics, we would use test doubles, such as stubs or mocks. This would involve creating a simple stub implementation of the CatanAgent, which would be a simple class which implements every method of the interface, but does so with simple hard-coded behaviour. By creating predefined legal and trivial actions for testing, we can test whether the game dynamics function properly, if moves are processed, rules are enforced, and state transitions within gameplay are correct. This supports the principle of separation of concern, where the decision logic does not interfere at all with the testing of gameplay rules. 

b) [3 marks] Implement the idea in Java. 

public class StubCatanAgent implements CatanAgent{  

    public void init(int playerID){ 

        //do nothing, dont need to initialize for a stub 

    } 

    public Move chooseInitialSettlement(GameState state){ 

        //return the first legal option 

        return state.getLegalMoves().get(0); 

    } 

    public Move chooseInitialRoad(GameState state){ 

        //return the first legal option 

        return state.getLegalMoves().get(0); 

    } 

    public Move chooseMove(GameState state){ 

        //return the first legal option 

        return state.getLegalMoves().get(0); 

    } 

    public Map<ResourceType, Integer> chooseDiscard(GameState state,int discardCount){ 

        //new empty map to return, since the stub doesn't need to actually discard, and is only meant to test gameplay and flow logic 

        return new HashMap<>(); 

    }  

    public ResourceType chooseResource(GameState state){ 

        //return the first legal option for type of resource (ex: wood) 

        return state.getLegalResourceChoices().get(0); 

    } 

    public int chooseRobberTarget(GameState state, List<Integer> possibleTargets){ 

        //return the first legal option for a player to rob 

        return possibleTargets.get(0); 

    }  

    public DevelopmentCard chooseDevelopmentCard(GameState state){ 

        //return the first legal option for a development card 

        return state.getLegalDevelopmentCards().get(0); 

    }  

} 

 

c) [3 marks] What other solutions can you envision here? Name a solution you would 

anticipate from a software developer who is not familiar with the techniques you 

used. List 3-4 convincing points against their solution and in favor of yours. 

I would anticipate a software developer who is not familiar with the concept of test doubles such as mocks, stubs, or fakes to test this code using hard-coded conditional logic and flags in the code, rather than creating custom test doubles. This may include adding boolean flags such as isTesting, which would run certain simplified sections of code as tests, and may include wrapping agent logic in conditional statements to check for these flags. This strategy is not ideal for a number of reasons: 

Firstly, it causes code buildup and unnecessary complexity in production code. This violates the single responsibility principle, as test logic is to be kept separate from the decision-making process and game logic, which is not upheld in this case.  

Secondly, it leads to high coupling between components. The agent code still needs to exist and must be compiled each time it is used, and all dependencies must be resolved, meaning that the agents cannot be tested separately from the game engine itself. Using stubs means that the full and complicated agent code does not need to be fully developed in order to begin testing, as a simplified stub version is used instead.  

Thirdly, these tests are not reuseable and easily extendable. Because they are hard-coded within the business logic of the program, any key changes in game logic or agent behaviour means that the flags and test code must be updated anywhere it is used. When using the interface-based stubbing approach, new stub implementations can be created very simply, and will be isolated and avoids creating any unnecessary dependencies.  

Fourthly, the card-coded flag-based approach is very hard to decouple and remove later if it is no longer needed. This often leads to messy code and buildup of redundant or unnecessary code, which would involve increased tech debt to fix or remove. Because stubs are isolated, they can be easily ignored or deleted if they are no longer needed. 

d) [2.5 marks] What would you do if you realized no one in your company/unit/team 

knows about the techniques you used in this exercise? To whom, how, and what would 

you communicate to improve the software engineering process? What would be your 

expectations? How does this question relate to your engineering practice, e.g., as 

outlined by CEAB? 

If I found that nobody in my company, unit, or team knew about test double techniques, I woud decide to help intorduce the team to these concepts and would let them know how it can be used to improve current testing processes, rather than keeping the knowlesge to myself. I would introduce this to my teammates first, in a more casual way such as bringing it up during pair programming or while working together on development. I would also bering it up with a team lead or team manager to help them understand how it can be used to benefit the team as a whole. From here, they may be able to help the knowledge spread across the whole team or unit so that everybody understands the concept and how it can be used.  

I would communicate this information in several ways. First, while working with teammates, it would come up as a casual topic of discussion, perhaps a suggestion on uingtest doubles, and then a demonstration of what they are and how they work. When sharing with the team as a whole, this could be done in a group setting such as a meeting, knowlesge sharing session, or a ‘lunch and learn’ type setting. This enables people to see examples and ask questions they may have. I would also help produce written documentation and standards on this, as these would be required if the use of this technique becomes widespread within the unit.  

Based on these methods and target audience, I would expect to get a good reception from the group. The use of test double techniques is very common in software development, and it supports good software design principles. However, I would not accept this change to happen immediately. A new concept like this does take time to learn, and some people may have trouble adapting at first. Realistically, this would be gradually adopted by the group, but would be something that is checked for in code reviews and testing plans, in order to encourage safe software development practices. 

This relates to the CEAB engineering practice, as it supports the key concepts of professionalism and lifelong learning. These concepts are essential to professional work as an engineer and are demonstrated in the use and adoption of these techniques. Professionalism is done by sharing best practices and resources, and lifelong learning means being willing to learn new techniques and best practices and apply them to the work that is done in order to improve the product quality or outcomes. By sharing this knowledge and how it can be used to improve code safety and quality, we are supporting both of these essential components of engineering practice and professionalism.  
